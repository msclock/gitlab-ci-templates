# This presents a semantic release templates for automatic release management
# based on semantic-release, see https://www.npmjs.com/package/semantic-release.
#
# To configure the template refers to the variables section.
#
# Normally, the templates can apply the release workflows:
#   - [Distribution channels](https://semantic-release.gitbook.io/semantic-release/recipes/release-workflow/distribution-channels)
#   - [Maintenance release](https://semantic-release.gitbook.io/semantic-release/recipes/release-workflow/maintenance-releases)
#   - [Pre-release](https://semantic-release.gitbook.io/semantic-release/recipes/release-workflow/pre-releases)
#
# For more information about semantic-release, see https://github.com/semantic-release/semantic-release.

# @Description template for release publish
.release:
  image: msclock/semantic-release:2023-10-17T08-13-59Z
  rules:
    - !reference [.rules, Skip Release Commits]
    - if: |
        $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH ||
        $CI_COMMIT_REF_NAME =~ /^(alpha|beta|next|next-major)$/ ||
        $CI_COMMIT_REF_NAME =~ /^+([0-9])?(.{+([0-9]),x}).x$/
  variables:
    # Extra plugins for semantic-release to install. Default to the below plugins are for making a release
    # with preset release config _PRESEST_RELEASERC_CONFIG.
    RELEASE_EXTRA_PLUGINS: >-
      @semantic-release/changelog
      @semantic-release/git
      @semantic-release/exec
      conventional-changelog-conventionalcommits
    # If on, the older release will be overwritten by the new release.
    OVERRIDE_RELEASE: ''
    # If on, the triggered release will apply the preset release config _PRESEST_RELEASERC_CONFIG.
    USING_PRESET_RELEASERC: ''
    # The preset release config _PRESEST_RELEASERC_CONFIG saved in _PRESET_RELEASERC_FILE
    _PRESET_RELEASERC_FILE: .releaserc.js
    # The default preset release config for semantic-release, more details
    # see https://github.com/semantic-release/semantic-release/blob/master/docs/usage/configuration.md
    _PRESET_RELEASERC_CONFIG: |
      module.exports = {
        branches: [
          "+([0-9])?(.{+([0-9]),x}).x",
          "$CI_DEFAULT_BRANCH",
          "next",
          "next-major",
          { name: "beta", prerelease: true },
          { name: "alpha", prerelease: true },
        ],
        plugins: [
          [
            "@semantic-release/commit-analyzer",
            {
              preset: "angular",
              releaseRules: [
                { breaking: true, release: "major" },
                { type: "feat", release: "minor" },
                { type: "fix", release: "patch" },
                { type: "style", release: "patch" },
                { type: "refactor", release: "patch" },
                { type: "perf", release: "patch" },
                { type: "revert", release: "patch" },
                { type: "chore", scope: "deps", release: "patch" },
                { type: "build", release: false },
                { type: "ci", release: false },
                { type: "docs", release: false },
                { type: "test", release: false },
              ],
              parserOpts: {
                noteKeywords: ["BREAKING CHANGE", "BREAKING CHANGES", "BREAKING"]
              },
            },
          ],
          [
            "@semantic-release/release-notes-generator",
            {
              preset: "conventionalcommits",
              presetConfig: {
                types: [
                  { type: "feat", section: "Features" },
                  { type: "fix", section: "Bug Fixes" },
                  { type: "style", section: "Style" },
                  { type: "refactor", section: "Refactor" },
                  { type: "perf", section: "Performance" },
                  { type: "revert", section: "Reverts" },
                  { type: "chore", scope: "deps", section: "Dependencies" },
                  { type: "chore", section: "Chores" },
                  { type: "build", section: "Build" },
                  { type: "ci", section: "CI" },
                  { type: "docs", section: "Docs" },
                  { type: "test", section: "Tests" },
                ],
              },
              parserOpts: {
                noteKeywords: ["BREAKING CHANGE", "BREAKING CHANGES", "BREAKING"]
              },
            },
          ],
          ["@semantic-release/changelog", { changelogFile: "CHANGELOG.md", }],
          [
            "@semantic-release/exec",
            {
              publishCmd: [
                "git tag -a -f v$${nextRelease.version} --cleanup=whitespace -m '$${nextRelease.notes}'",
                "git push --force origin v$${nextRelease.version}"
              ].join(" && "),
            }
          ],
          [
            "@semantic-release/git",
            {
              assets: ["CHANGELOG.md"],
              message: "chore(release): $${nextRelease.version} [skip ci]\n\n$${nextRelease.notes}",
            },
          ],
          "@semantic-release/gitlab",
        ],
      };
    # Optional NPM registry to speed up dependencies installation.
    NPM_SOURCE: ''
    # Optional options for semantic-release cli.
    SEMANTIC_RELEASE_OPTIONS: ''
    # The api of gitlab for semantic-release
    GITLAB_PREFIX: /api/v4
    # The instance of gitlab
    GITLAB_URL: $CI_SERVER_URL
  script:
    - !reference [.security_check_sensible, script]
    - |
      if [[ -n "$NPM_SOURCE" ]]; then
        echo "Configuring npm registry from $NPM_SOURCE"
        npm config set registry "$NPM_SOURCE"
        npm get registry
      fi

      echo "Install semantic release plugins..." >> /dev/stderr
      npm install -g semantic-release \
        @semantic-release/release-notes-generator \
        @semantic-release/gitlab $RELEASE_EXTRA_PLUGINS
    - !reference [.security_git_config, script]
    - |
      if [[ -n "$USING_PRESET_RELEASERC" ]]; then
        echo "Generating preset releaserc $_PRESET_RELEASERC_FILE..."
        echo "$_PRESET_RELEASERC_CONFIG" > "$_PRESET_RELEASERC_FILE"
      fi

      echo "Update the local tags" >> /dev/stderr
      git fetch --tags --force

      if [[ $CI_DEBUG_TRACE =~ ^(1|true)$ ]]; then
        echo "Local tags:" >> /dev/stderr
        git tag -l
        echo "Remote tags:" >> /dev/stderr
        git ls-remote --tags origin
      fi

      echo "Delete the local tags that no longer exist on the remote repository" >> /dev/stderr
      git fetch origin --prune --prune-tags

      echo "Detect conflicting release and delete the existing tag and release if possible"
      if [[ -n "$OVERRIDE_RELEASE" ]]; then
        _dry_run_output=$(semantic-release -d --ci)
        _verify_version=$(echo "$_dry_run_output" | grep -oP "(?<=Skip ).+(?= tag creation in dry-run mode)") || true
        if [[ $(git tag -l) =~ (^|[[:space:]])"$_verify_version"($|[[:space:]]) ]]; then
          echo "Found and delete conflicting tag $_verify_version"
          git push origin :refs/tags/"$_verify_version" || true
          git tag -d "$_verify_version"

          echo "Delete release if possible"
          curl --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
              --request DELETE "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases/$_verify_version" || true
        else
          echo "No conflicting release found"
        fi
      fi

      if [[ -z "$SEMANTIC_RELEASE_OPTIONS" ]]; then
        _release_output=$(semantic-release)
      else
        echo "Be careful!! CLI arguments take precedence over options configured in the configuration file"
        _release_output=$(semantic-release "$SEMANTIC_RELEASE_OPTIONS")
      fi
      echo -e "Semantic Release Output:\n$_release_output"
      new_release_version=$(echo "$_release_output" | grep -oP "(?<=Published release ).+(?= on)") || true
      echo "new_release_version=$new_release_version" >> semantic.env
  after_script:
    # Finally, remove the preset releaserc file
    - |
      [[ -n "$USING_PRESET_RELEASERC" && -f "$_PRESET_RELEASERC_FILE" ]] && rm -f "$_PRESET_RELEASERC_FILE"
  artifacts:
    reports:
      dotenv: semantic.env # Expose the new release version to dotenv

# @Description post release pipeline, default to run tag post pipeline
.post_pipelilne:
  extends:
    - .schedule_pipeline
  rules:
    - !reference [.rules, Skip Release Commits]
    - if: |
        ( $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH ||
        $CI_COMMIT_REF_NAME =~ /^(alpha|beta|next|next-major)$/ ||
        $CI_COMMIT_REF_NAME =~ /^+([0-9])?(.{+([0-9]),x}).x$/ ) &&
        $RELEASE_POST_PIPELINE_TYPE
  variables:
    # '', 'tag' or 'branch'
    RELEASE_POST_PIPELINE_TYPE: ''
  before_script:
    - |
      if [[ -z "$new_release_version" ]]; then
        echo "Skip post release pipeline because new_release_version is not set" >> /dev/stderr
        exit 0
      fi

      if [[ "$RELEASE_POST_PIPELINE_TYPE" == "tag" ]]; then
        export SCHEDULE_REF="v$new_release_version"
      fi

      if [[ "$RELEASE_POST_PIPELINE_TYPE" == "branch" ]]; then
        if [[ -z "$CI_COMMIT_BRANCH" ]]; then
          echo "Invalid schedule pipeline, and CI_COMMIT_BRANCH must be set if RELEASE_POST_PIPELINE_TYPE is branch" >> /dev/stderr
          exit 1
        fi
        export SCHEDULE_REF="$CI_COMMIT_BRANCH"
      fi

      echo "Ready to schedule pipeline type: $RELEASE_POST_PIPELINE_TYPE, ref: $SCHEDULE_REF"
