.security_check_sensible:
  script: |
    if [[ $CI_DEBUG_TRACE =~ ^(1|true)$ ]]; then
        echo "Enable CI_DEBUG_TRACE, and some sensible info will be printed. Please be careful!!!"
        set -x
    fi

.security_git_config:
  script: |
    # Prepare config for git
    if [[ -n "$CI_COMMIT_BRANCH" ]]; then
        git remote set-url origin "https://gitlab-ci-token:${GITLAB_TOKEN:-$CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    elif [[ -n "$CI_MERGE_REQUEST_IID" ]]; then
        git remote set-url origin "https://gitlab-ci-token:${GITLAB_TOKEN:-$CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_MERGE_REQUEST_SOURCE_PROJECT_PATH}.git"
    fi

    git config --global user.name ${CI_USRE_NAME:-gitlab-ci[bot]}
    git config --global user.email ${CI_USER_EMAIL:-noreply+gitlab-ci[bot]@${CI_SERVER_HOST}}
    git config --global lfs.locksverify true

# @Description make changes on codebase
.make_changes:
  variables:
    MAKE_CHANGES_MSG: ''
    MAKE_CHANGES_ON_PR: ''
    MAKE_CHANGES_EXIT: ''
  script:
    - !reference [.security_check_sensible, script]
    - !reference [.security_git_config, script]
    - |
      if [[ -n "$(git status -s)" ]]; then

        if [[ -n "$MAKE_CHANGES_ON_PR" ]]; then
            temp_branch=temp_black_${CI_COMMIT_SHA:0:12}
            git checkout -B "$temp_branch" --
        fi

        git add -u .
        git commit -m "${MAKE_CHANGES_MSG:-ci: automated commit changes from CI job}" -m "job url:$CI_JOB_URL"
        if [[ -n "$MAKE_CHANGES_ON_PR" ]]; then
            git push origin "$temp_branch"
            curl --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
                --request POST "$CI_SERVER_URL/api/v4/projects/$CI_PROJECT_ID/merge_requests" \
                --form "source_branch=$temp_branch" \
                --form "target_branch=$CI_COMMIT_REF_NAME" \
                --form "title=PR from $temp_branch"
        elif [[ -n "$CI_COMMIT_BRANCH" ]]; then
            git push origin HEAD:"$CI_COMMIT_BRANCH"
        elif [[ -n "$CI_MERGE_REQUEST_IID" ]]; then
            git push origin HEAD:"$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME"
        fi
      else
        echo "Working tree clean. Nothing to make changes.";
        exit 0
      fi

      if [[ -z "$MAKE_CHANGES_EXIT" ]]; then
          exit 0
      else
          exit 1
      fi

# @Description proxy backend based on clash
.proxy_backend:
  services:
    - name: msclock/clash:2023-08-10T04-27-58Z
      alias: proxy_backend
      entrypoint:
        - ''
      command:
        - sh
        - -c
        - set -xe && wget $CLASH_PROXY_SUB -O /root/.config/clash/config.yaml && ./clash
  variables:
    CLASH_PROXY_SUB: ''
    PROXY_WHITE_LIST: 10.0.0.0/8,192.168.0.0/16,127.0.0.1,172.16.0.0/16,$CI_SERVER_HOST
    ENABLE_PROXY: '1'
  before_script:
    - !reference [.security_check_sensible, script]
    - |
      if [[ -z "$CLASH_PROXY_SUB" ]]; then
        echo "No proxy subscribe found." >> /dev/stderr
        exit 1
      fi

      if [[ -n "$ENABLE_PROXY" ]]; then

        export HTTP_PROXY="http://proxy_backend:7890"
        export http_proxy="$HTTP_PROXY"

        export HTTPS_PROXY="$HTTP_PROXY"
        export https_proxy="$HTTP_PROXY"

        export FTP_PROXY=$HTTP_PROXY
        export ftp_proxy=$HTTP_PROXY

        export ALL_PROXY=$HTTP_PROXY
        export all_proxy=$HTTP_PROXY

        export NO_PROXY="$PROXY_WHITE_LIST"
        export no_proxy="$NO_PROXY"
        sleep 3 # wait for proxy_backend is ready
      fi

# @Description pre-commit template
.pre_commit:
  extends:
    - .make_changes
  stage: .pre
  rules:
    - if: $PRE_COMMIT_SKIP_BRANCH_PIPELINE && $CI_COMMIT_BRANCH
      when: never
    - if: $PRE_COMMIT_SKIP_MR_PIPELINE && $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never
    - if: $PRE_COMMIT_AUTO_FIX_BRANCH_ONLY && $CI_PIPELINE_SOURCE == "merge_request_event"
      variables:
        PRE_COMMIT_AUTO_FIX: ''
      when: on_success
      exists:
        - .pre-commit-config.yaml
    - if: $PRE_COMMIT_DEDUPLICATE_MR_AND_BRANCH == "true" && $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    - if: $PRE_COMMIT_AUTO_FIX_MR_ONLY && $CI_PIPELINE_SOURCE != "merge_request_event"
      variables:
        PRE_COMMIT_AUTO_FIX: ''
      exists:
        - .pre-commit-config.yaml
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_EVENT_TYPE != "detached"
      variables: # don't support autofix for merged_result or merge_train pipelines, configure branch fixing instead
        PRE_COMMIT_AUTO_FIX: ''
      exists:
        - .pre-commit-config.yaml
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      exists:
        - .pre-commit-config.yaml
      when: on_success
    - if: $CI_COMMIT_BRANCH
      exists:
        - .pre-commit-config.yaml
      when: on_success
    - when: never
  variables:
    PRE_COMMIT_AUTO_FIX: '1'
    PRE_COMMIT_DEDUPLICATE_MR_AND_BRANCH: 'true'
    MAKE_CHANGES_MSG: 'ci: auto fixes from pre-commit'
    MAKE_CHANGES_EXIT: '1'
    PRE_COMMIT_HOME: $CI_PROJECT_DIR/.cache/.pre-commit
  image: msclock/pre-commit:2023-08-10T09-27-52Z
  cache:
    key: ${CI_COMMIT_REF_SLUG}-pre-commit-cache
    paths:
      - $PRE_COMMIT_HOME
  script:
    - !reference [.security_check_sensible, script]
    - |
      if [[ -n "$PRE_COMMIT_AUTO_FIX_BRANCH_ONLY" && -n "$PRE_COMMIT_AUTO_FIX_MR_ONLY" ]]; then
          echo "Invalid configuration. PRE_COMMIT_AUTO_FIX_BRANCH_ONLY and PRE_COMMIT_AUTO_FIX_MR_ONLY are mutually exclusive"
          exit 1
      fi

      status=0

      pre-commit run --all-files || status=$?

      if [[ $status -eq 0 ]]; then
          exit 0  # We're all good, pipeline can proceed
      fi

      _init_fail_code=3

      if [[ $status -eq $_init_fail_code ]]; then
          echo "pre-commit init plugins failed!! Please retry it again!!!"
          exit 1
      fi

      if [[ -z "$PRE_COMMIT_AUTO_FIX" ]]; then
          exit $status # Fail the job with status holding exit code
      fi
    - !reference [.make_changes, script]

# @Description template of the base image of devcontainer
.devcontainer:
  image: msclock/devcontainer:2023-08-10T04-27-58Z

# @Description devcontainer build
.devcontainer::build:
  extends:
    - .devcontainer
  variables:
    IMAGE_NAME: ''
    PUSH: ''
    PLATFORM: ''
    SUB_FOLDER: ''
  script:
    - |
      set -x

      build_extra=(--workspace-folder .)

      if [ -n "$SUB_FOLDER" ]; then
          build_extra+=(--config "$SUB_FOLDER")
      fi

      if [ -n "$IMAGE_NAME" ]; then
          build_extra+=(--image-name "$IMAGE_NAME")
      fi

      if [ -n "$PUSH" ]; then
          build_extra+=(--push)
      fi

      if [ -n "$PLATFORM" ]; then
          build_extra+=(--platform "$PLATFORM")
      fi

      # build image by devcontainer
      devcontainer build "${build_extra[@]}"

# @Description template of the base image of act
.act:
  image: msclock/act:2023-08-12T17-40-49Z

# @Description template for release publish
.release:
  image: msclock/semantic-release:2023-08-17T08-27-38Z
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      # for prerelease on beta or alpha
    - if: $CI_COMMIT_REF_NAME == "beta"
    - if: $CI_COMMIT_REF_NAME == "alpha"
  variables:
    RELEASE_EXTRA_PLUGINS: ''
    OVERRIDE_RELEASE: ''
    USING_PRESET_RELEASERC: ''
    _PRESET_RELEASERC_FILE: .releaserc
    NPM_SOURCE: ''
    SEMANTIC_RELEASE_OPTIONS: ''
    # Env for plugin gitlab
    GITLAB_PREFIX: /api/v4
    GITLAB_URL: $CI_SERVER_URL
  script:
    - !reference [.security_check_sensible, script]
    - |
      if [[ -n "$NPM_SOURCE" ]]; then
        echo "Configuring npm registry from $NPM_SOURCE"
        npm config set registry "$NPM_SOURCE"
        npm get registry
      fi

      echo "Install semantic release plugins..." >> /dev/stderr
      npm install -g semantic-release \
        @semantic-release/release-notes-generator \
        @semantic-release/gitlab $RELEASE_EXTRA_PLUGINS
    - !reference [.security_git_config, script]
    - |
      if [[ -n "$USING_PRESET_RELEASERC" ]]; then
        echo "Generating preset releaserc $_PRESET_RELEASERC_FILE..."
      cat >"$_PRESET_RELEASERC_FILE"<<EOF
      {
          "branches":[
              "$CI_DEFAULT_BRANCH",
              {
                  "name": "alpha",
                  "prerelease": true
              },
              {
                  "name": "beta",
                  "prerelease": true
              }
          ],
          "plugins": [
              "@semantic-release/commit-analyzer",
              "@semantic-release/release-notes-generator",
              "@semantic-release/gitlab"
          ]
      }
      EOF
      fi

      if [[ $CI_DEBUG_TRACE =~ ^(1|true)$ ]]; then
        echo "Local tags:" >> /dev/stderr
        git tag -l
        echo "Remote tags:" >> /dev/stderr
        git ls-remote --tags origin
      fi

      echo "Delete the local tags that no longer exist on the remote repository" >> /dev/stderr
      git fetch origin --prune-tags

      echo "Detect conflicting release and delete the existing tag and release if possible"
      if [[ -n "$OVERRIDE_RELEASE" ]]; then
        _dry_run_output=$(semantic-release -d --ci)
        _verify_version=$(echo "$_dry_run_output" | grep -oP "(?<=Skip ).+(?= tag creation in dry-run mode)") || true
        if [[ $(git tag -l) =~ (^|[[:space:]])"$_verify_version"($|[[:space:]]) ]]; then
            echo "Found and delete conflicting tag $_verify_version"
            git push origin :refs/tags/"$_verify_version" || true
            git tag -d "$_verify_version"

            echo "Delete release if possible"
            curl --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
                --request DELETE "$CI_SERVER_URL/api/v4/projects/$CI_PROJECT_ID/releases/$_verify_version" || true
        else
            echo "No conflicting release found"
        fi
      fi

      if [[ -z "$SEMANTIC_RELEASE_OPTIONS" ]]; then
        _release_output=$(semantic-release)
      else
        echo "Be careful!! CLI arguments take precedence over options configured in the configuration file"
        _release_output=$(semantic-release "$SEMANTIC_RELEASE_OPTIONS")
      fi
      echo -e "Semantic Release Output:\n$_release_output"
      new_release_version=$(echo "$_release_output" | grep -oP "(?<=Published release ).+(?= on)") || true
      echo "new_release_version=$new_release_version" >> semantic.env
  after_script:
    - |
      [[ -n "$USING_PRESET_RELEASERC" && -f "$_PRESET_RELEASERC_FILE" ]] && rm -f "$_PRESET_RELEASERC_FILE"
  artifacts:
    reports:
      dotenv: semantic.env

# @Description template for path changes based on git subcommand diff
.path-filter:
  image: msclock/pre-commit:2023-08-10T09-27-52Z
  variables:
    WORKING_DIRECTORY: .
    REF: ''
    BASE: ''
    FILTERS: ''
    LIST_FILES: none
    INITIAL_FETCH_DEPTH: '100'
  before_script:
    - |
      apt update && apt install jq -y
  script:
    - |
      # set -x

      # Set the working directory if provided
      if [[ -n "$WORKING_DIRECTORY" ]]; then
        cd "$WORKING_DIRECTORY"
      fi

      # Checkout the specified ref
      if [[ -n "$REF" ]]; then
        git checkout "$REF"
      fi

      if [[ -z "$FILTERS" ]]; then
        echo "Invalid FILTERS configuration."
        exit 1
      fi

      if [[ -n "$BASE" ]]; then
        all_changes_output=$(git diff --no-renames --name-status "$BASE"..HEAD)
      else
        all_changes_output=$(git diff --no-renames --name-status HEAD)
      fi

      # Expose to dotenv artifact
      function expose() {
        expose_key=$1
        content=${2%'\n'} # trim the newline

        case "$LIST_FILES" in
          csv)
            content=$(echo -e "$content" | awk '{print "\""$2"\""}'| paste -sd ",")
            ;;
          json)
            content=$(echo -e "$content" | awk '{print $2}' | jq -R . | jq -s .)
            ;;
          shell)
            content=$(echo -e "$content" | awk '{print $2}' | xargs -I{} echo -e "{}")
            ;;
          escape)
            content=$(echo -e "$content" | awk '{print $2}' | xargs -I{} echo -e "{}" | sed 's/[^a-zA-Z0-9,._+:@%/-]/\\&/g')
            ;;
        esac

        echo "$expose_key='${content//$'\n'/\\n}'" >> filter.env # escape new line into dotenv
      }

      echo -e "all_changes_output:\n$all_changes_output"
      echo "raw_all_changes_output='${all_changes_output//$'\n'/\\n}'" > filter.env
      expose "all_changes_output" "$all_changes_output"

      keys=$(echo "$FILTERS" | jq -r "keys[]")
      declare -A patterns_map
      for category in $keys; do
        patterns_map["$category"]=$(echo -e "$FILTERS" | jq -r ".$category[]")
      done

      for category in "${!patterns_map[@]}"; do
        patterns="${patterns_map[$category]}"
        echo -e "patterns from $category:\n${patterns[@]}"
        changes=""
        while IFS= read -r line; do
          filename=$(echo "$line" | awk '{print $2}')
          for pattern in $patterns; do
            if echo "$filename" | grep -Pq "$pattern"; then
              changes+="$line\n"
              break
            fi
          done
        done <<< "$all_changes_output"

        echo -e "changes from $category:\n$changes"
        expose "$category" "$changes"
      done
  artifacts:
    reports:
      dotenv: filter.env

# @Description template for deploy mkdocs
.pages-mkdocs:
  stage: deploy
  variables:
    PIP_CACHE_DIR: $CI_PROJECT_DIR/.cache/pip
    PAGES_BRANCH: gl-pages
    VRESION_DOCS: ''
    MKDOCS_EXTRA_PLUGINS: ''
  image: python:3.8-bullseye
  script:
    - !reference [.security_check_sensible, script]
    - !reference [.security_git_config, script]
    - |
      echo "Install mkdocs plugins: mkdocs ${MKDOCS_EXTRA_PLUGINS}" >> /dev/stderr
      pip install mkdocs ${MKDOCS_EXTRA_PLUGINS}

      if [[ -n "$VRESION_DOCS" ]]; then
        pip install mike

        git fetch origin $PAGES_BRANCH
        git checkout -b $PAGES_BRANCH origin/$PAGES_BRANCH || echo "Pages branch not deployed yet."
        git checkout $CI_COMMIT_SHA

        mike deploy --rebase --prefix public -p -b $PAGES_BRANCH -u $CI_COMMIT_TAG latest
        mike set-default --rebase --prefix public -p -b $PAGES_BRANCH latest
        git checkout $PAGES_BRANCH -- public/
      else
        mkdocs build --site-dir public
      fi
  artifacts:
    paths:
      - public/
  cache:
    key: ${CI_COMMIT_REF_SLUG}-pages-pip-cache
    paths:
      - $PIP_CACHE_DIR
